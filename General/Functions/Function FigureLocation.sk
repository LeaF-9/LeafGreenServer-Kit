# Circle
function particleLocation_Circle(baseloc: location, count: number, radius: number, a: number = 0) :: locations:
	set {_count} to floor({_count})
	set {_rad} to 0 + {_a}
	set {_basevec} to vector({_radius}, 0, 0)
	loop {_count} times:
		set {_v} to {_basevec}
		rotate {_v} around y-axis by {_rad}		
		set {_el} to {_baseloc} ~ {_v}
		add {_el} to {_returnlocs::*}
		add 360 / {_count} to {_rad}
	return {_returnlocs::*}

# Sphere
function particleLocation_Sphere(baseloc: location, count: number, radius: number, chance: number = 100) :: locations:
	set {_count} to floor({_count})
	loop {_count} times:
		set {_v} to randomVector({_radius})
		set {_el} to {_baseloc} ~ {_v}
		chance of {_chance}%:
			if {_returnlocs::*} does not contain {_el}:
				add {_el} to {_returnlocs::*}
	return {_returnlocs::*}

# Spiral
# count: 一周におけるパーティクル量
# density: 一周する際に上がる距離(m)
# height: 最高高度(m)
# arad: 初期値(option)
function particleLocation_Spiral(baseloc: location, count: number, density: number, radius: number, height: number, arad: number = 0, clockwize: boolean = true) :: locations:
	if {_density} <= 0:
		log "Densityの値が不正です"
		stop
	set {_basevec} to vector({_radius}, 0, 0)
	set {_count} to floor({_count})
	set {_rad} to {_arad}
	set {_addrad} to 360 / {_count}
	if {_clockwize} is false:
		set {_addrad} to {_addrad} * -1
	set {_el} to {_baseloc}
	set {_addy} to {_density} / {_count}
	set {_basey} to y-pos of {_baseloc}
	while y-pos of {_baseloc} - {_basey} <= {_height}:
		# 円
		loop {_count} times:
			if y-pos of {_baseloc} - {_basey} > {_height}:
				continue
			set {_v} to {_basevec}
			rotate {_v} around y-axis by {_rad}
			set {_el} to {_baseloc} ~ {_v}
			add {_el} to {_returnlocs::*}
			add {_addy} to y-pos of {_baseloc}
			add {_addrad} to {_rad}
	return {_returnlocs::*}

# Tornado
# count: 一周におけるパーティクル量
# density: 一周する際に上がる距離(m)
# radius: 一周する際に増加する半径(m)
# height: 最高高度(m)
# arad: 初期値(option)
function particleLocation_Tornado(baseloc: location, count: number, density: number, radius: number, height: number, arad: number = 0, clockwize: boolean = true) :: locations:
	if {_density} <= 0:
		log "Densityの値が不正です"
		stop
	set {_count} to floor({_count})
	set {_rad} to {_arad}
	set {_addrad} to 360 / {_count}
	if {_clockwize} is false:
		set {_addrad} to {_addrad} * -1
	set {_el} to {_baseloc}
	set {_addy} to {_density} / {_count}
	set {_basey} to y-pos of {_baseloc}
	set {_addm} to {_radius} / {_count}
	set {_meter} to 0
	while y-pos of {_baseloc} - {_basey} <= {_height}:
		# 円
		loop {_count} times:
			if y-pos of {_baseloc} - {_basey} > {_height}:
				continue
			add {_addm} to {_meter}
			set {_basevec} to vector({_meter}, 0, 0)
			set {_v} to {_basevec}
			rotate {_v} around y-axis by {_rad}
			set {_el} to {_baseloc} ~ {_v}
			add {_el} to {_returnlocs::*}
			add {_addy} to y-pos of {_baseloc}
			add {_addrad} to {_rad}
	return {_returnlocs::*}

# vertical circle
function particleLocation_CircleV(baseloc: location, count: number, radius: number) :: locations:
	set {_count} to floor({_count})

	set {_basevec} to setVector({_baseloc}, location 10 meters in front of {_baseloc})
	set {_rotateloc} to {_baseloc}
	add 90 to pitch of {_rotateloc}
	set {_rotatevec} to setVector({_rotateloc}, location 10 meters in front of {_rotateloc}, {_radius})
	set {_rad} to 0
	loop {_count} times:
		set {_v} to {_rotatevec}
		rotate {_v} around {_basevec} by {_rad}
		set {_el} to {_baseloc} ~ {_v}
		add {_el} to {_returnlocs::*}
		add 360 / {_count} to {_rad}
	return {_ returnlocs::*}

# vertical spiral
function particleLocation_SpiralV(baseloc: location, count: number, density: number, radius: number, front: number, arad: number = 0, clockwize: boolean = true) :: locations:
	if {_density} <= 0:
		log "Densityの値が不正です"
		stop
	set {_count} to floor({_count})

	set {_basevec} to setVector({_baseloc}, location 10 meters in front of {_baseloc})
	set {_rotateloc} to {_baseloc}
	add 90 to pitch of {_rotateloc}
	set {_rotatevec} to setVector({_rotateloc}, location 10 meters in front of {_rotateloc}, {_radius})

	set {_rad} to {_arad}
	set {_addrad} to 360 / {_count}
	if {_clockwize} is false:
		set {_addrad} to {_addrad} * -1
	set {_el} to {_baseloc}
	set {_addf} to {_density} / {_count}
	set {_basef} to {_baseloc}
	set {_m} to 0
	while {_m} <= {_front}:
		# 円
		loop {_count} times:
			if {_m} > {_front}:
				continue
			set {_v} to {_rotatevec}
			rotate {_v} around {_basevec} by {_rad}

			set {_loc} to location {_m} meters in front of {_baseloc}
			set {_el} to {_loc} ~ {_v}
			add {_el} to {_returnlocs::*}
			add {_addf} to {_m}
			add {_addrad} to {_rad}
	return {_returnlocs::*}

# vertical tornado
function particleLocation_TornadoV(baseloc: location, count: number, density: number, radius: number, front: number, arad: number = 0, clockwize: boolean = true) :: locations:
	if {_density} <= 0:
		log "Densityの値が不正です / %{_density}%"
		stop
	set {_count} to floor({_count})

	set {_basevec} to setVector({_baseloc}, location 10 meters in front of {_baseloc})
	set {_rotateloc} to {_baseloc}
	add 90 to pitch of {_rotateloc}
	set {_rotatevec} to setVector({_rotateloc}, location 10 meters in front of {_rotateloc})

	set {_rad} to {_arad}
	set {_addrad} to 360 / {_count}
	if {_clockwize} is false:
		set {_addrad} to {_addrad} * -1
	set {_el} to {_baseloc}
	set {_addf} to {_density} / {_count}
	set {_basef} to {_baseloc}
	set {_addr} to {_radius} / {_count}
	set {_sumr} to 0
	set {_m} to 0
	while {_m} <= {_front}:
		# 円
		loop {_count} times:
			if {_m} > {_front}:
				continue

			add {_addr} to {_sumr}
			set {_v} to {_rotatevec}
			set {_v} to {_v} * vector({_sumr}, {_sumr}, {_sumr})
			rotate {_v} around {_basevec} by {_rad}

			set {_loc} to location {_m} meters in front of {_baseloc}
			set {_el} to {_loc} ~ {_v}

			add {_el} to {_returnlocs::*}
			add {_addf} to {_m}
			add {_addrad} to {_rad}
	return {_returnlocs::*}



# ランダムに座標をずらす関数
function moveRandomLocation(loc: location, max: number) :: location:
	set {_return} to {_loc}
	add a random number between {_max} * -1 and {_max} to x-pos of {_return}
	add a random number between {_max} * -1 and {_max} to y-pos of {_return}
	add a random number between {_max} * -1 and {_max} to z-pos of {_return}
	return {_return}